
# ML-Master: An AI-for-AI Agent for Autonomous Machine Learning

This project is a Python implementation of the AI-for-AI agent described in the paper "ML-Master: Towards AI-for-AI via Integration of Exploration and Reasoning". It provides a general framework for an AI agent that can autonomously solve machine learning problems through a process of exploration and reasoning.

## Core Concepts

The ML-Master agent is designed to mimic the iterative workflow of a human data scientist. It combines two core concepts:

1.  **Balanced Multi-Trajectory Exploration**: The agent explores the vast space of possible solutions using a Monte Carlo Tree Search (MCTS). Each node in the tree represents a specific version of a solution (e.g., a piece of code). The agent uses the UCT algorithm to balance exploring new, uncertain paths (exploration) with refining known, promising paths (exploitation).

2.  **Steerable Reasoning**: The agent uses a Large Language Model (LLM), such as Google's Gemini, as its reasoning engine. To guide the LLM, ML-Master employs an **Adaptive Memory** mechanism. Before generating a new solution, it constructs a detailed context (memory) from previous attempts, including the code, execution feedback, and performance scores from parent and sibling nodes in the MCTS tree. This allows the agent to learn from its mistakes and make informed decisions.

The interplay between these two components creates a powerful feedback loop: Exploration generates diverse experiences, and Reasoning learns from these experiences to guide future exploration.

## Project Structure

```
ml-master/
├── src/
│   ├── ml_master/
│   │   ├── __init__.py
│   │   ├── core.py         # Defines the MCTSNode, the core data structure
│   │   ├── explorer.py     # Implements the MCTS exploration logic
│   │   ├── reasoner.py     # Implements the Steerable Reasoning and LLM interaction
│   │   └── main.py         # Main entry point for running the agent
│   └── __init__.py
├── titanic/                # Example project directory
│   ├── train.csv
│   ├── test.csv
│   ├── gender_submission.csv
│   ├── task_description.txt # Project-specific instructions for the agent
│   └── generated_submissions/ # Output directory for AI-generated solutions
├── .gitignore
├── pyproject.toml          # Project dependencies managed by `uv`
└── README.md               # This file
```

## How It Works: A General Workflow

1.  **Initialization**: The `main.py` script is launched, pointing to a specific project (e.g., `titanic`). It reads the `task_description.txt` for that project to understand its goal.
2.  **MCTS Cycle Begins**:
    a.  **Select**: The `Explorer` traverses the MCTS tree to find the most promising node to expand.
    b.  **Reason**: The `Reasoner` constructs the adaptive memory from the selected node's ancestors and siblings.
    c.  **Generate**: The `Reasoner` sends a detailed prompt (containing the task description and the adaptive memory) to the LLM, asking it to `Draft`, `Debug`, or `Improve` the solution.
    d.  **Verify**: The `Explorer` takes the code generated by the LLM and runs it in a sandboxed environment. For a standard ML problem, this involves:
        i.  Writing the code to a file.
        ii. Executing the script, which is expected to train a model and print a performance metric (e.g., accuracy).
        iii. Parsing the metric from the script's output.
    e.  **Backpropagate**: The performance metric is converted into a reward, which is then propagated back up the MCTS tree, updating the statistics of all parent nodes.
3.  **Iteration**: The agent repeats the MCTS cycle, continuously refining its solution based on the feedback from previous attempts.

## Case Study: Solving the Titanic Competition

This repository includes a pre-configured example to demonstrate ML-Master's capabilities on the classic Kaggle Titanic competition.

### Goal

The agent's goal, as defined in `titanic/task_description.txt`, is to write a Python script that:
1.  Loads and preprocesses the Titanic dataset.
2.  Trains a classification model.
3.  Evaluates the model on a local validation set.
4.  Prints the final validation accuracy.

### Running the Titanic Example

1.  **Prerequisites**: Make sure you have Python 3.10+ and `uv` installed.

2.  **Install Dependencies**:
    ```bash
    uv sync
    ```

3.  **Set Environment Variable**: You must have a Gemini API key for the agent's reasoning engine.
    ```bash
    export GEMINI_API_KEY='your_api_key_here'
    ```

4.  **Run the Agent**:
    ```bash
    uv run python -m src.ml_master.main --project_name titanic --num_iterations 20
    ```

### Observed Behavior

When run on the Titanic problem, ML-Master demonstrates a clear learning progression:

*   **Iteration 1**: The agent typically generates a simple baseline script, which might include basic data loading and a simple model, achieving an initial accuracy.
*   **Subsequent Iterations**: The agent receives a positive reward and is prompted to `Improve`. It then starts adding more sophisticated features and techniques it has learned from the LLM's training data:
    *   **Feature Engineering**: It learns to handle missing `Age` values by using passenger titles, create a `FamilySize` feature, and one-hot encode categorical variables.
    *   **Advanced Modeling**: It often progresses from a simple `LogisticRegression` to a more powerful `RandomForestClassifier` or `GradientBoostingClassifier`.
    *   **Hyperparameter Tuning**: In later stages, it can even implement `RandomizedSearchCV` to optimize the model's hyperparameters.

The output logs will show the `Q/N` (average reward) of the root node increasing over time, reflecting the agent's successful improvement of the solution. The generated scripts, which can be found in `titanic/generated_submissions`, provide a fascinating step-by-step look into the agent's evolving strategy.

## Conclusion

This project successfully implements the ML-Master framework, demonstrating its ability to autonomously solve a classic machine learning problem. It serves as a powerful proof-of-concept for the potential of AI-for-AI systems and provides a solid foundation for future research and development in this exciting field.
